# Combining bash, python and c++ to
    # Run several solvers from the file "main.cpp"
    # Import output-files from "main.cpp"
    # Create figures
    
# Peter Even Killingstad and Karl Jacobsen

#%%
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import argparse
from subprocess import call
import os

#%%
def initializeSolvers(numberOfSimulations,amplificationFactor, N, a, b, c, noLU):
	""" Applying bash to run c++ program """    
	call(["./Allclean"])
	if noLU:
	    solvers = ["gaussianTridiagonal","gaussianTridiagonalSymmetric"]
	else:        	    
	    solvers = ["gaussianTridiagonal","gaussianTridiagonalSymmetric","luLib"]    
	for solver in solvers:
	    if solver == "luLib" and int(numberOfSimulations) >= 2:
	        numberOfSimulations = str(2)
	        if int(N) > 1000:
	            return                
	    call(["./Allrun", solver, numberOfSimulations,amplificationFactor, N, a, b, c])
#%%	
def readScalarValues(noLU):
	""" Reading in files containing scalars generated by C++ """
	gaussianTridiagonalScalars = pd.read_table("results/gaussianTridiagonal_scalars.csv", 
			             delimiter=',') # Seems to need full addres
	gaussianTridiagonalSymmetricScalars = pd.read_table("results/gaussianTridiagonalSymmetric_scalars.csv", 
			             delimiter=',') # Seems to need full addres
	if not noLU:
	    LUScalars = pd.read_table("results/luLib_scalars.csv", 
			             delimiter=',') # Seems to need full addres
	    return gaussianTridiagonalScalars, gaussianTridiagonalSymmetricScalars, LUScalars
	
	return gaussianTridiagonalScalars, gaussianTridiagonalSymmetricScalars, 0    
#%%
def readSolutionVectors(numberOfSimulations, noLU):
	""" Reading in files containing vectors generated by C++ """
	x = {}
	gaussianTridiagonal = {}
	gaussianTridiagonalSymmetric = {}
	exactSolution = {}
	LU = {}

	for key in xrange(numberOfSimulations):    
		gaussianTridiagonal[key] = pd.read_table("results/gaussianTridiagonal_numerical%d.csv" %(key+1), 
		                 delimiter=',').values
		gaussianTridiagonal[key] = np.reshape(gaussianTridiagonal[key], -1)
		gaussianTridiagonalSymmetric[key] = pd.read_table("results/gaussianTridiagonalSymmetric_numerical%d.csv" %(key+1), 
		                 delimiter=',').values
		gaussianTridiagonalSymmetric[key] = np.reshape(gaussianTridiagonalSymmetric[key], -1)
		if not noLU:
		    if key < 2:        
		    
		        LU[key] = pd.read_table("results/luLib_numerical%d.csv" %(key+1), 
		                 delimiter=',').values
		        LU[key] = np.reshape(gaussianTridiagonalSymmetric[key], -1)
		
		exactSolution[key] = pd.read_table("results/gaussianTridiagonalSymmetric_exact%d.csv" %(key+1), 
		                 delimiter=',').values
		exactSolution[key] = np.reshape(exactSolution[key], -1)
		
		N = len(gaussianTridiagonal[key])
		h = 1./(N+1)
		x[key] = np.linspace(h, 1.-h, N)
	return x, gaussianTridiagonal, gaussianTridiagonalSymmetric,LU, exactSolution

#%% 
def plot_logTimes(gaussianTridiagonalScalars, gaussianTridiagonalSymmetricScalars, LUScalars, noLU):
	plt.figure()
	legends = ['Thomas', 'Symmetric']
	plt.plot(gaussianTridiagonalScalars.log_h, gaussianTridiagonalScalars.logTimeUsed)
	plt.hold('on')
	plt.plot(gaussianTridiagonalSymmetricScalars.log_h, gaussianTridiagonalSymmetricScalars.logTimeUsed)
	if not noLU:
	    plt.plot(LUScalars.log_h, LUScalars.logTimeUsed)         
	    legends.append('LU')                 
	plt.legend(legends, fontsize = 'large', loc = 'upper right')
	plt.title('CPU times', fontsize = 'xx-large')
	plt.xlabel('log h', fontsize = 'xx-large')
	plt.ylabel('log time', fontsize = 'xx-large')
	plt.savefig('results/logTimes.pdf')

#%%
def plot_errors(algorithmScalarValues, algorithmNname, amplificationFactor):
	relativeError = algorithmScalarValues.log_rel_error
	plt.figure()
	log_h = algorithmScalarValues.log_h
	plt.plot(log_h, relativeError)
	plt.title('Relative error '+algorithmNname, fontsize = 'xx-large')
	plt.xlabel('log h', fontsize = 'xx-large')
	plt.ylabel('Relative error', fontsize = 'xx-large')
	if int(amplificationFactor) == 2:
	    plt.ylim(-10,-1)        
	filename = ('results/relativeError_'+ algorithmNname + amplificationFactor +'.pdf')
	plt.savefig(filename)


#%% Plot numerical and exact
def plot_numericalAndExactSolution(x, numberOfSimulations, numericalSolution, exactSolution,algorithm):
	plt.figure()
	legends = []
	for key in xrange(numberOfSimulations):
		plt.plot(x[key], numericalSolution[key])#, x[key], gaussianTridiagonal[key])
		N = len(numericalSolution[key])    
		legends.append('N = %d' %N)
	plt.plot(x[key], exactSolution[key])
	legends.append("exact solution")
	plt.legend(legends, fontsize = 'large', loc = 'upper right')
	plt.title( algorithm, fontsize = 'xx-large')
	plt.xlabel('x', fontsize = 'xx-large')
	plt.ylabel('v(x)', fontsize = 'xx-large')
	filename = ('results/comparison_'+algorithm+'.pdf')
	plt.savefig(filename)


if __name__ == "__main__":
    # Setting up for reading of command line arguments 
    if not os.path.isdir('results'):
        os.mkdir('results')
    parser = argparse.ArgumentParser(description="starts a c++ program solving u''=f(x), reads and  plots.")
    parser.add_argument("numberOfSimulations", type=str, default=3, help="Number of times to refine mesh")
    
    parser.add_argument("amplificationFactor", type=str, default=10, help="amplification of mesh size")

    parser.add_argument("initialMesh", type=str, default=10, help="inital dimension of mesh. ex: 10")

    parser.add_argument("LowerDiagonal", type=str, default=-1.0,
                        help="lower diagonal value")
    parser.add_argument("Diagonal",type=str ,default=2.0,  help="diagonal value")
    
    parser.add_argument("UpperDiagonal",type=str ,default=-1.0,  help="upper diagonal value")
    
    parser.add_argument("--noshow", action='store_true', default=False, help='Do not show plots')

    parser.add_argument("--noLU", action='store_true', default=False, help='Do not calculate LU')
    
    args = parser.parse_args()

    initializeSolvers(args.numberOfSimulations, args.amplificationFactor, args.initialMesh, args.LowerDiagonal, args.Diagonal, args.UpperDiagonal, args.noLU)
    
    gaussianTridiagonalScalars, gaussianTridiagonalSymmetricScalars, LUScalars = readScalarValues(args.noLU)
    
    x, gaussianTridiagonal, gaussianTridiagonalSymmetric, LU, exactSolution = readSolutionVectors(int(args.numberOfSimulations), args.noLU)
    
    plot_logTimes(gaussianTridiagonalScalars, gaussianTridiagonalSymmetricScalars, LUScalars, args.noLU)
    
    plot_numericalAndExactSolution(x, int(args.numberOfSimulations), gaussianTridiagonalSymmetric, exactSolution, "gaussianTridiagonalSymmetric")
    plot_errors(gaussianTridiagonalScalars, "gaussianTridiagonal", args.amplificationFactor)
    
    if not args.noshow:
        plt.show()